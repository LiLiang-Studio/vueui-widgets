(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-212fc1b0"],{"12f0":function(t,i,s){},"272c":function(t,i,s){"use strict";var a=s("12f0"),n=s.n(a);n.a},f6fd:function(t,i,s){"use strict";s.r(i);var a=function(){var t=this,i=t.$createElement,s=t._self._c||i;return s("div",[s("div",{staticClass:"page-title"},[t._v("LoadingBar 加载进度条")]),s("p",[t._v("全局创建一个显示页面加载、异步请求、文件上传等的加载进度条。")]),s("br"),s("p",[t._v(" LoadingBar 只会在全局创建一个，因此在任何位置调用的方法都会控制这同一个组件。 主要使用场景是路由切换和Ajax，因为这两者都不能拿到精确的进度，LoadingBar 会模拟进度， 当然也可以通过update()方法来传入一个精确的进度，比如在文件上传时会很有用，具体见API。 ")]),s("div",{staticClass:"page-sub-title"},[t._v("点击 Start 开始进度，点击 Finish 结束。在调用start()方法后，组件会自动模拟进度，当调用finish()或error()时，补全进度并自动消失。")]),s("Button",{on:{click:t.start}},[t._v("开始")]),s("Button",{staticStyle:{"margin-left":"4px"},on:{click:t.finish}},[t._v("完成")]),s("Button",{staticStyle:{"margin-left":"4px"},on:{click:t.error}},[t._v("错误")]),s("Button",{staticStyle:{"margin-left":"4px"},on:{click:t.destroy}},[t._v("注销")]),s("div",{staticClass:"page-sub-title"},[t._v("通过直接调用以下方法来使用组件：")]),t._m(0),s("div",{staticClass:"page-sub-title"},[t._v("另外提供了全局配置和全局销毁的方法：")]),t._m(1),s("br"),s("br"),s("p",[t._v("如果要在路由中使用，请用Vue.LoadingBar 代替 this.$Loading，API完全一致")])],1)},n=[function(){var t=this,i=t.$createElement,s=t._self._c||i;return s("ul",{staticClass:"list"},[s("li",[t._v("this.$Loading.start()")]),s("li",[t._v("this.$Loading.finish()")]),s("li",[t._v("this.$Loading.error()")]),s("li",[t._v("this.$Loading.update(percent)")])])},function(){var t=this,i=t.$createElement,s=t._self._c||i;return s("ul",{staticClass:"list"},[s("li",[t._v("this.$Loading.config(options)")]),s("li",[t._v("this.$Loading.destroy()")])])}],e={methods:{start(){this.$Loading.start()},finish(){this.$Loading.finish()},error(){this.$Loading.error()},destroy(){this.$Loading.destroy()}}},r=e,o=(s("272c"),s("2be6")),l=Object(o["a"])(r,a,n,!1,null,"710affa3",null);i["default"]=l.exports}}]);